<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>MDAnalysis.analysis.rms &mdash; MDAnalysis 0.15.1-dev0 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.15.1-dev0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 0.15.1-dev0 documentation"
          href="../../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../../_static/mdanalysis-logo.ico"/>
    <link rel="top" title="MDAnalysis 0.15.1-dev0 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">MDAnalysis 0.15.1-dev0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/mdanalysis-logo-200x150.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for MDAnalysis.analysis.rms</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-</span>
<span class="c1"># vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4</span>
<span class="c1">#</span>
<span class="c1"># MDAnalysis --- http://www.MDAnalysis.org</span>
<span class="c1"># Copyright (c) 2006-2015 Naveen Michaud-Agrawal, Elizabeth J. Denning, Oliver</span>
<span class="c1"># Beckstein and contributors (see AUTHORS for the full list)</span>
<span class="c1">#</span>
<span class="c1"># Released under the GNU Public Licence, v2 or any higher version</span>
<span class="c1">#</span>
<span class="c1"># Please cite your use of MDAnalysis in published work:</span>
<span class="c1">#</span>
<span class="c1"># N. Michaud-Agrawal, E. J. Denning, T. B. Woolf, and O. Beckstein.</span>
<span class="c1"># MDAnalysis: A Toolkit for the Analysis of Molecular Dynamics Simulations.</span>
<span class="c1"># J. Comput. Chem. 32 (2011), 2319--2327, doi:10.1002/jcc.21787</span>
<span class="c1">#</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Calculating root mean square quantities --- :mod:`MDAnalysis.analysis.rms`</span>
<span class="sd">==========================================================================</span>

<span class="sd">:Author: Oliver Beckstein, David L. Dotson</span>
<span class="sd">:Year: 2012</span>
<span class="sd">:Copyright: GNU Public License v2</span>

<span class="sd">.. versionadded:: 0.7.7</span>
<span class="sd">.. versionchanged:: 0.11.0</span>
<span class="sd">   Added :class:`RMSF` analysis.</span>

<span class="sd">The module contains code to analyze root mean square quantities such</span>
<span class="sd">as the coordinat root mean square distance (:class:`RMSD`) or the</span>
<span class="sd">per-residue root mean square fluctuations (:class:`RMSF`).</span>

<span class="sd">This module uses the fast QCP algorithm [Theobald2005]_ to calculate</span>
<span class="sd">the root mean square distance (RMSD) between two coordinate sets (as</span>
<span class="sd">implemented in</span>
<span class="sd">:func:`MDAnalysis.lib.qcprot.CalcRMSDRotationalMatrix`).</span>

<span class="sd">When using this module in published work please cite [Theobald2005]_.</span>

<span class="sd">.. SeeAlso::</span>

<span class="sd">   :mod:`MDAnalysis.analysis.align`</span>
<span class="sd">       aligning structures based on RMSD</span>
<span class="sd">   :mod:`MDAnalysis.lib.qcprot`</span>
<span class="sd">        implements the fast RMSD algorithm.</span>

<span class="sd">Examples</span>
<span class="sd">--------</span>

<span class="sd">Calculating RMSD for multiple domains</span>
<span class="sd">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

<span class="sd">In this example we will globally fit a protein to a reference</span>
<span class="sd">structure and investigate the relative movements of domains by</span>
<span class="sd">computing the RMSD of the domains to the reference. The example is a</span>
<span class="sd">DIMS trajectory of adenylate kinase, which samples a large</span>
<span class="sd">closed-to-open transition. The protein consists of the CORE, LID, and</span>
<span class="sd">NMP domain.</span>

<span class="sd">* superimpose on the closed structure (frame 0 of the trajectory),</span>
<span class="sd">  using backbone atoms</span>

<span class="sd">* calculate the backbone RMSD and RMSD for CORE, LID, NMP (backbone atoms)</span>

<span class="sd">The trajectory is included with the test data files. The data in</span>
<span class="sd">:attr:`RMSD.rmsd` is plotted with :func:`matplotlib.pyplot.plot`::</span>

<span class="sd">   import MDAnalysis</span>
<span class="sd">   from MDAnalysis.tests.datafiles import PSF,DCD,CRD</span>
<span class="sd">   u = MDAnalysis.Universe(PSF,DCD)</span>
<span class="sd">   ref = MDAnalysis.Universe(PSF,DCD)     # reference closed AdK (1AKE) (with the default ref_frame=0)</span>
<span class="sd">   #ref = MDAnalysis.Universe(PSF,CRD)    # reference open AdK (4AKE)</span>

<span class="sd">   import MDAnalysis.analysis.rms</span>

<span class="sd">   R = MDAnalysis.analysis.rms.RMSD(u, ref,</span>
<span class="sd">              select=&quot;backbone&quot;,             # superimpose on whole backbone of the whole protein</span>
<span class="sd">              groupselections=[&quot;backbone and (resid 1-29 or resid 60-121 or resid 160-214)&quot;,   # CORE</span>
<span class="sd">                               &quot;backbone and resid 122-159&quot;,                                   # LID</span>
<span class="sd">                               &quot;backbone and resid 30-59&quot;],                                    # NMP</span>
<span class="sd">              filename=&quot;rmsd_all_CORE_LID_NMP.dat&quot;)</span>
<span class="sd">   R.run()</span>
<span class="sd">   R.save()</span>

<span class="sd">   import matplotlib.pyplot as plt</span>
<span class="sd">   rmsd = R.rmsd.T   # transpose makes it easier for plotting</span>
<span class="sd">   time = rmsd[1]</span>
<span class="sd">   fig = plt.figure(figsize=(4,4))</span>
<span class="sd">   ax = fig.add_subplot(111)</span>
<span class="sd">   ax.plot(time, rmsd[2], &#39;k-&#39;,  label=&quot;all&quot;)</span>
<span class="sd">   ax.plot(time, rmsd[3], &#39;k--&#39;, label=&quot;CORE&quot;)</span>
<span class="sd">   ax.plot(time, rmsd[4], &#39;r--&#39;, label=&quot;LID&quot;)</span>
<span class="sd">   ax.plot(time, rmsd[5], &#39;b--&#39;, label=&quot;NMP&quot;)</span>
<span class="sd">   ax.legend(loc=&quot;best&quot;)</span>
<span class="sd">   ax.set_xlabel(&quot;time (ps)&quot;)</span>
<span class="sd">   ax.set_ylabel(r&quot;RMSD ($\AA$)&quot;)</span>
<span class="sd">   fig.savefig(&quot;rmsd_all_CORE_LID_NMP_ref1AKE.pdf&quot;)</span>


<span class="sd">Functions</span>
<span class="sd">---------</span>

<span class="sd">.. autofunction:: rmsd</span>

<span class="sd">Analysis classes</span>
<span class="sd">----------------</span>

<span class="sd">.. autoclass:: RMSD</span>
<span class="sd">   :members:</span>

<span class="sd">   .. attribute:: rmsd</span>

<span class="sd">      Results are stored in this N×3 :class:`numpy.ndarray` array,</span>
<span class="sd">      (frame, time (ps), RMSD (Å)).</span>

<span class="sd">.. autoclass:: RMSF</span>
<span class="sd">   :members:</span>

<span class="sd">   .. attribute:: rmsf</span>

<span class="sd">      Results are stored in this N-length :class:`numpy.ndarray` array,</span>
<span class="sd">      giving RMSFs for each of the given atoms.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">six.moves</span> <span class="kn">import</span> <span class="nb">zip</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">MDAnalysis.lib.qcprot</span> <span class="kn">as</span> <span class="nn">qcp</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.exceptions</span> <span class="kn">import</span> <span class="n">SelectionError</span><span class="p">,</span> <span class="n">NoDataError</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.lib.log</span> <span class="kn">import</span> <span class="n">ProgressMeter</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.lib.util</span> <span class="kn">import</span> <span class="n">asiterable</span>


<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;MDAnalysis.analysis.rmsd&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="rmsd"><a class="viewcode-back" href="../../../documentation_pages/analysis/rms.html#MDAnalysis.analysis.rms.rmsd">[docs]</a><span class="k">def</span> <span class="nf">rmsd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">superposition</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns RMSD between two coordinate sets `a` and `b`.</span>

<span class="sd">    `a` and `b` are arrays of the coordinates of N atoms of shape N*3</span>
<span class="sd">    as generated by, e.g.,</span>
<span class="sd">    :meth:`MDAnalysis.core.AtomGroup.AtomGroup.coordinates`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a, b : array_like</span>
<span class="sd">        coordinates to align</span>
<span class="sd">    weights : array_like (optional)</span>
<span class="sd">        1D array with weights, use to compute weighted average</span>
<span class="sd">    center : bool (optional)</span>
<span class="sd">        subtract center of geometry before calculation. With weights given</span>
<span class="sd">        compute weighted average as center.</span>
<span class="sd">    superposition : bool (optional)</span>
<span class="sd">        perform a rotational and translational superposition with the fast QCP</span>
<span class="sd">        algorithm [Theobald2005]_ before calculating the RMSD</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rmsd : float</span>
<span class="sd">        RMSD between a and b</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; u = Universe(PSF,DCD)</span>
<span class="sd">    &gt;&gt;&gt; bb = u.select_atoms(&#39;backbone&#39;)</span>
<span class="sd">    &gt;&gt;&gt; A = bb.positions.copy()  # coordinates of first frame</span>
<span class="sd">    &gt;&gt;&gt; u.trajectory[-1]         # forward to last frame</span>
<span class="sd">    &gt;&gt;&gt; B = bb.positions.copy()  # coordinates of last frame</span>
<span class="sd">    &gt;&gt;&gt; rmsd(A, B, center=True)</span>
<span class="sd">    3.9482355416565049</span>

<span class="sd">    .. versionchanged: 0.8.1</span>
<span class="sd">       *center* keyword added</span>
<span class="sd">    .. versionchanged: 0.14.0</span>
<span class="sd">       *superposition* keyword added</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;a and b must have same shape&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;weights must have same length as a/b&#39;</span><span class="p">)</span>
        <span class="c1"># weights are constructed as relative to the mean</span>
        <span class="n">relative_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
        <span class="n">relative_weights</span> <span class="o">=</span> <span class="n">relative_weights</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">relative_weights</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="c1"># superposition only works if structures are centered</span>
    <span class="k">if</span> <span class="n">center</span> <span class="ow">or</span> <span class="n">superposition</span><span class="p">:</span>
        <span class="c1"># make copies (do not change the user data!)</span>
        <span class="c1"># weights=None is equivalent to all weights 1</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">superposition</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">relative_weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">relative_weights</span> <span class="o">=</span> <span class="n">relative_weights</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">qcp</span><span class="o">.</span><span class="n">CalcRMSDRotationalMatrix</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span>
                                            <span class="n">relative_weights</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">relative_weights</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                <span class="o">*</span> <span class="p">((</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span> <span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">process_selection</span><span class="p">(</span><span class="n">select</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a canonical selection dictionary.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    select : str / tuple / dict</span>
<span class="sd">        str -&gt; Any valid string selection</span>
<span class="sd">        dict -&gt; {&#39;mobile&#39;:sel1, &#39;reference&#39;:sel2}</span>
<span class="sd">        tuple -&gt; (sel1, sel2)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        selections for &#39;reference&#39; and &#39;mobile&#39;. Values are guarenteed to be</span>
<span class="sd">        iterable (so that one can provide selections to retain order)</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    The dictionary input for ``select`` can be generated by</span>
<span class="sd">    :func:`fasta2select` based on ClustalW_ or STAMP_ sequence alignment.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">select</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">select</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;reference&#39;</span><span class="p">:</span> <span class="n">select</span><span class="p">,</span> <span class="s1">&#39;mobile&#39;</span><span class="p">:</span> <span class="n">select</span><span class="p">}</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">select</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">select</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mobile&#39;</span><span class="p">:</span> <span class="n">select</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;reference&#39;</span><span class="p">:</span> <span class="n">select</span><span class="p">[</span><span class="mi">1</span><span class="p">]}</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;select must contain two selection strings &quot;</span>
                             <span class="s2">&quot;(reference, mobile)&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">select</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="c1"># compatability hack to use new nomenclature</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">select</span><span class="p">[</span><span class="s1">&#39;mobile&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">select</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;use key &#39;mobile&#39; instead of deprecated &#39;target&#39;; &quot;</span>
                          <span class="s2">&quot;&#39;target&#39; will be removed in 0.8&quot;</span><span class="p">,</span>
                          <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">select</span><span class="p">[</span><span class="s1">&#39;mobile&#39;</span><span class="p">]</span>
            <span class="n">select</span><span class="p">[</span><span class="s1">&#39;reference&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;select dictionary must contain entries for keys &quot;</span>
                           <span class="s2">&quot;&#39;mobile&#39; and &#39;reference&#39;.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;select&#39; must be either a string, 2-tuple, or dict&quot;</span><span class="p">)</span>
    <span class="n">select</span><span class="p">[</span><span class="s1">&#39;mobile&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">asiterable</span><span class="p">(</span><span class="n">select</span><span class="p">[</span><span class="s1">&#39;mobile&#39;</span><span class="p">])</span>
    <span class="n">select</span><span class="p">[</span><span class="s1">&#39;reference&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">asiterable</span><span class="p">(</span><span class="n">select</span><span class="p">[</span><span class="s1">&#39;reference&#39;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">select</span>


<div class="viewcode-block" id="RMSD"><a class="viewcode-back" href="../../../documentation_pages/analysis/rms.html#MDAnalysis.analysis.rms.RMSD">[docs]</a><span class="k">class</span> <span class="nc">RMSD</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class to perform RMSD analysis on a trajectory.</span>

<span class="sd">    Run the analysis with :meth:`RMSD.run`, which stores the results</span>
<span class="sd">    in the array :attr:`RMSD.rmsd`::</span>

<span class="sd">       frame    time (ps)    RMSD (A)</span>

<span class="sd">    This class uses Douglas Theobald&#39;s fast QCP algorithm</span>
<span class="sd">    [Theobald2005]_ to calculate the RMSD.</span>

<span class="sd">    .. versionadded:: 0.7.7</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">traj</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">select</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span>
                 <span class="n">groupselections</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s2">&quot;rmsd.dat&quot;</span><span class="p">,</span>
                 <span class="n">mass_weighted</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">tol_mass</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">ref_frame</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Setting up the RMSD analysis.</span>

<span class="sd">        The RMSD will be computed between *select* and *reference* for</span>
<span class="sd">        all frames in the trajectory in *universe*.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        traj : :class:`MDAnalysis.Universe`</span>
<span class="sd">            universe that contains a trajectory</span>
<span class="sd">        reference : :class:`MDAnalysis.Universe` (optional)</span>
<span class="sd">            reference coordinates, if ``None`` current frame of *traj* is used</span>
<span class="sd">        select : str / dict / tuple (optional)</span>
<span class="sd">            The selection to operate on; can be one of:</span>

<span class="sd">            1. any valid selection string for</span>
<span class="sd">               :meth:`~MDAnalysis.core.AtomGroup.AtomGroup.select_atoms` that</span>
<span class="sd">               produces identical selections in *mobile* and *reference*; or</span>

<span class="sd">            2. a dictionary ``{&#39;mobile&#39;:sel1, &#39;reference&#39;:sel2}`` (the</span>
<span class="sd">               :func:`MDAnalysis.analysis.align.fasta2select` function returns</span>
<span class="sd">               such a dictionary based on a ClustalW_ or STAMP_ sequence</span>
<span class="sd">               alignment); or</span>
<span class="sd">            3. a tuple ``(sel1, sel2)``</span>

<span class="sd">            When using 2. or 3. with *sel1* and *sel2* then these selections</span>
<span class="sd">            can also each be a list of selection strings (to generate a</span>
<span class="sd">            AtomGroup with defined atom order as described under</span>
<span class="sd">            :ref:`ordered-selections-label`).</span>
<span class="sd">        groupselections : list (optional)</span>
<span class="sd">            A list of selections as described for *select*. Each selection</span>
<span class="sd">            describes additional RMSDs to be computed *after the structures</span>
<span class="sd">            have be superpositioned* according to *select*. The output contains</span>
<span class="sd">            one additional column for each selection. [``None``]</span>

<span class="sd">            .. Note:: Experimental feature. Only limited error checking</span>
<span class="sd">                      implemented.</span>
<span class="sd">        filename : str (optional)</span>
<span class="sd">            write RSMD into file file :meth:`RMSD.save`</span>
<span class="sd">        mass_weighted : bool (optional)</span>
<span class="sd">             do a mass-weighted RMSD fit</span>
<span class="sd">        tol_mass : float (optional)</span>
<span class="sd">             Reject match if the atomic masses for matched atoms differ by more</span>
<span class="sd">             than `tol_mass`</span>
<span class="sd">        ref_frame : int (optional)</span>
<span class="sd">             frame index to select frame from `reference`</span>


<span class="sd">        .. _ClustalW: http://www.clustal.org/</span>
<span class="sd">        .. _STAMP: http://www.compbio.dundee.ac.uk/manuals/stamp.4.2/</span>

<span class="sd">        .. versionadded:: 0.7.7</span>
<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           *groupselections* added</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">universe</span> <span class="o">=</span> <span class="n">traj</span>
        <span class="k">if</span> <span class="n">reference</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reference</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reference</span> <span class="o">=</span> <span class="n">reference</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">select</span> <span class="o">=</span> <span class="n">process_selection</span><span class="p">(</span><span class="n">select</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">groupselections</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">groupselections</span> <span class="o">=</span> <span class="p">[</span><span class="n">process_selection</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">groupselections</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">groupselections</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mass_weighted</span> <span class="o">=</span> <span class="n">mass_weighted</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tol_mass</span> <span class="o">=</span> <span class="n">tol_mass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref_frame</span> <span class="o">=</span> <span class="n">ref_frame</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ref_atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">[</span><span class="s1">&#39;reference&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traj_atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">[</span><span class="s1">&#39;mobile&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_atoms</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traj_atoms</span><span class="p">):</span>
            <span class="n">errmsg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Reference and trajectory atom selections do &quot;</span><span class="o">+</span>
                      <span class="s2">&quot;not contain the same number of atoms: &quot;</span><span class="o">+</span>
                      <span class="s2">&quot;N_ref={0:d}, N_traj={1:d}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_atoms</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span>
                                                        <span class="bp">self</span><span class="o">.</span><span class="n">traj_atoms</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">SelectionError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;RMS calculation for {0:d} atoms.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_atoms</span><span class="p">)))</span>
        <span class="n">mass_mismatches</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_atoms</span><span class="o">.</span><span class="n">masses</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj_atoms</span><span class="o">.</span><span class="n">masses</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol_mass</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mass_mismatches</span><span class="p">):</span>
            <span class="c1"># diagnostic output:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Atoms: reference | trajectory&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ar</span><span class="p">,</span> <span class="n">at</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_atoms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj_atoms</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">ar</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">at</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;{0!s:&gt;4} {1:3d} {2!s:&gt;3} {3!s:&gt;3} {4:6.3f}  |  {5!s:&gt;4} {6:3d} {7!s:&gt;3} {8!s:&gt;3} {9:6.3f}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ar</span><span class="o">.</span><span class="n">segid</span><span class="p">,</span> <span class="n">ar</span><span class="o">.</span><span class="n">resid</span><span class="p">,</span> <span class="n">ar</span><span class="o">.</span><span class="n">resname</span><span class="p">,</span> <span class="n">ar</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">ar</span><span class="o">.</span><span class="n">mass</span><span class="p">,</span>
                                 <span class="n">at</span><span class="o">.</span><span class="n">segid</span><span class="p">,</span> <span class="n">at</span><span class="o">.</span><span class="n">resid</span><span class="p">,</span> <span class="n">at</span><span class="o">.</span><span class="n">resname</span><span class="p">,</span> <span class="n">at</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">at</span><span class="o">.</span><span class="n">mass</span><span class="p">))</span>
            <span class="n">errmsg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Inconsistent selections, masses differ by more than&quot;</span>
                     <span class="o">+</span> <span class="s2">&quot;{0:f}; mis-matching atoms are shown above.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">tol_mass</span><span class="p">))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">SelectionError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">mass_mismatches</span>

        <span class="c1"># TODO:</span>
        <span class="c1"># - make a group comparison a class that contains the checks above</span>
        <span class="c1"># - use this class for the *select* group and the additional</span>
        <span class="c1">#   *groupselections* groups each a dict with reference/mobile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">groupselections_atoms</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">{</span>
                <span class="s1">&#39;reference&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;reference&#39;</span><span class="p">]),</span>
                <span class="s1">&#39;mobile&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;mobile&#39;</span><span class="p">]),</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">groupselections</span><span class="p">]</span>
        <span class="c1"># sanity check</span>
        <span class="k">for</span> <span class="n">igroup</span><span class="p">,</span> <span class="p">(</span><span class="n">sel</span><span class="p">,</span> <span class="n">atoms</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">groupselections</span><span class="p">,</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">groupselections_atoms</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="s1">&#39;mobile&#39;</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="s1">&#39;reference&#39;</span><span class="p">]):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s1">&#39;SelectionError: Group Selection&#39;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">SelectionError</span><span class="p">(</span>
                    <span class="s2">&quot;Group selection {0}: {1} | {2}: Reference and trajectory &quot;</span>
                    <span class="s2">&quot;atom selections do not contain the same number of atoms: &quot;</span>
                    <span class="s2">&quot;N_ref={3}, N_traj={4}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">igroup</span><span class="p">,</span> <span class="n">sel</span><span class="p">[</span><span class="s1">&#39;reference&#39;</span><span class="p">],</span> <span class="n">sel</span><span class="p">[</span><span class="s1">&#39;mobile&#39;</span><span class="p">],</span>
                        <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="s1">&#39;reference&#39;</span><span class="p">]),</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="s1">&#39;mobile&#39;</span><span class="p">])))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rmsd</span> <span class="o">=</span> <span class="bp">None</span>

<div class="viewcode-block" id="RMSD.run"><a class="viewcode-back" href="../../../documentation_pages/analysis/rms.html#MDAnalysis.analysis.rms.RMSD.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">mass_weighted</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ref_frame</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform RMSD analysis on the trajectory.</span>

<span class="sd">        A number of parameters can be changed from the defaults. The</span>
<span class="sd">        result is stored as the array :attr:`RMSD.rmsd`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start, stop, step : int (optional)</span>
<span class="sd">            start and stop frame index with step size</span>
<span class="sd">        mass_weighted : bool (optional)</span>
<span class="sd">            overwrite object default to do a mass-weighted RMSD fit</span>
<span class="sd">        ref_frame : int</span>
<span class="sd">             frame index to select frame from *reference*</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mass_weighted</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">mass_weighted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mass_weighted</span>
        <span class="k">if</span> <span class="n">ref_frame</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ref_frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_frame</span>

        <span class="n">natoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj_atoms</span><span class="o">.</span><span class="n">n_atoms</span>
        <span class="n">trajectory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span>
        <span class="n">traj_atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj_atoms</span>

        <span class="k">if</span> <span class="n">mass_weighted</span><span class="p">:</span>
            <span class="c1"># if performing a mass-weighted alignment/rmsd calculation</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_atoms</span><span class="o">.</span><span class="n">masses</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_atoms</span><span class="o">.</span><span class="n">masses</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">weight</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c1"># reference centre of mass system</span>
        <span class="n">current_frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">frame</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Move to the ref_frame</span>
            <span class="c1"># (coordinates MUST be stored in case the ref traj is advanced</span>
            <span class="c1"># elsewhere or if ref == mobile universe)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reference</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="n">ref_frame</span><span class="p">]</span>
            <span class="n">ref_com</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_atoms</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">()</span>
            <span class="c1"># makes a copy</span>
            <span class="n">ref_coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_atoms</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="n">ref_com</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">groupselections_atoms</span><span class="p">:</span>
                <span class="n">groupselections_ref_coords_64</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">reference</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;reference&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">positions</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">groupselections</span><span class="p">]</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="c1"># Move back to the original frame</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reference</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="n">current_frame</span><span class="p">]</span>
        <span class="n">ref_coordinates_64</span> <span class="o">=</span> <span class="n">ref_coordinates</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># allocate the array for selection atom coords</span>
        <span class="n">traj_coordinates</span> <span class="o">=</span> <span class="n">traj_atoms</span><span class="o">.</span><span class="n">positions</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">groupselections_atoms</span><span class="p">:</span>
            <span class="c1"># Only carry out a rotation if we want to calculate secondary</span>
            <span class="c1"># RMSDs.</span>
            <span class="c1"># R: rotation matrix that aligns r-r_com, x~-x~com</span>
            <span class="c1">#    (x~: selected coordinates, x: all coordinates)</span>
            <span class="c1"># Final transformed traj coordinates: x&#39; = (x-x~_com)*R + ref_com</span>
            <span class="n">rot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>  <span class="c1"># allocate space</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">rot</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rot</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c1"># RMSD timeseries</span>
        <span class="n">n_frames</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">trajectory</span><span class="p">))[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">:</span><span class="n">step</span><span class="p">])</span>
        <span class="n">rmsd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_frames</span><span class="p">,</span> <span class="mi">3</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">groupselections_atoms</span><span class="p">)))</span>

        <span class="n">percentage</span> <span class="o">=</span> <span class="n">ProgressMeter</span><span class="p">(</span>
            <span class="n">n_frames</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s2">&quot;RMSD </span><span class="si">%(rmsd)5.2f</span><span class="s2"> A at frame &quot;</span>
            <span class="s2">&quot;</span><span class="si">%(step)5d</span><span class="s2">/</span><span class="si">%(numsteps)d</span><span class="s2">  [</span><span class="si">%(percentage)5.1f%%</span><span class="s2">]</span><span class="se">\r</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">ts</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">trajectory</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">:</span><span class="n">step</span><span class="p">]):</span>
            <span class="c1"># shift coordinates for rotation fitting</span>
            <span class="c1"># selection is updated with the time frame</span>
            <span class="n">x_com</span> <span class="o">=</span> <span class="n">traj_atoms</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">()</span>
            <span class="n">traj_coordinates</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">traj_atoms</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="n">x_com</span>

            <span class="n">rmsd</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">frame</span><span class="p">,</span> <span class="n">trajectory</span><span class="o">.</span><span class="n">time</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">groupselections_atoms</span><span class="p">:</span>
                <span class="c1"># 1) superposition structures Need to transpose coordinates</span>
                <span class="c1"># such that the coordinate array is 3xN instead of Nx3. Also</span>
                <span class="c1"># qcp requires that the dtype be float64 (I think we swapped</span>
                <span class="c1"># the position of ref and traj in CalcRMSDRotationalMatrix so</span>
                <span class="c1"># that R acts **to the left** and can be broadcasted; we&#39;re</span>
                <span class="c1"># saving one transpose. [orbeckst])</span>
                <span class="n">rmsd</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">qcp</span><span class="o">.</span><span class="n">CalcRMSDRotationalMatrix</span><span class="p">(</span>
                    <span class="n">ref_coordinates_64</span><span class="p">,</span>
                    <span class="n">traj_coordinates</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span> <span class="n">natoms</span><span class="p">,</span> <span class="n">rot</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span>
                <span class="n">R</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">rot</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

                <span class="c1"># Transform each atom in the trajectory (use inplace ops to</span>
                <span class="c1"># avoid copying arrays) (Marginally (~3%) faster than</span>
                <span class="c1"># &quot;ts.positions[:] = (ts.positions - x_com) * R + ref_com&quot;.)</span>
                <span class="n">ts</span><span class="o">.</span><span class="n">positions</span> <span class="o">-=</span> <span class="n">x_com</span>
                <span class="c1"># R acts to the left &amp; is broadcasted N times.</span>
                <span class="n">ts</span><span class="o">.</span><span class="n">positions</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">positions</span> <span class="o">*</span> <span class="n">R</span>
                <span class="n">ts</span><span class="o">.</span><span class="n">positions</span> <span class="o">+=</span> <span class="n">ref_com</span>

                <span class="c1"># 2) calculate secondary RMSDs</span>
                <span class="k">for</span> <span class="n">igroup</span><span class="p">,</span> <span class="p">(</span><span class="n">refpos</span><span class="p">,</span> <span class="n">atoms</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                        <span class="nb">zip</span><span class="p">(</span><span class="n">groupselections_ref_coords_64</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">groupselections_atoms</span><span class="p">),</span> <span class="mi">3</span><span class="p">):</span>
                    <span class="n">rmsd</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">igroup</span><span class="p">]</span> <span class="o">=</span> <span class="n">qcp</span><span class="o">.</span><span class="n">CalcRMSDRotationalMatrix</span><span class="p">(</span>
                        <span class="n">refpos</span><span class="p">,</span> <span class="n">atoms</span><span class="p">[</span><span class="s1">&#39;mobile&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>
                        <span class="n">atoms</span><span class="p">[</span><span class="s1">&#39;mobile&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># only calculate RMSD by setting the Rmatrix to None (no need</span>
                <span class="c1"># to carry out the rotation as we already get the optimum RMSD)</span>
                <span class="n">rmsd</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">qcp</span><span class="o">.</span><span class="n">CalcRMSDRotationalMatrix</span><span class="p">(</span>
                    <span class="n">ref_coordinates_64</span><span class="p">,</span>
                    <span class="n">traj_coordinates</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span> <span class="n">natoms</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span>

            <span class="n">percentage</span><span class="o">.</span><span class="n">echo</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">frame</span><span class="p">,</span> <span class="n">rmsd</span><span class="o">=</span><span class="n">rmsd</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rmsd</span> <span class="o">=</span> <span class="n">rmsd</span></div>

<div class="viewcode-block" id="RMSD.save"><a class="viewcode-back" href="../../../documentation_pages/analysis/rms.html#MDAnalysis.analysis.rms.RMSD.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save RMSD from :attr:`RMSD.rmsd` to text file *filename*.</span>

<span class="sd">        Parameter</span>
<span class="sd">        ---------</span>
<span class="sd">        filename : str (optional)</span>
<span class="sd">            if no filename is given the default provided to the constructor is</span>
<span class="sd">            used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rmsd</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s2">&quot;rmsd has not been calculated yet&quot;</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rmsd</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Wrote RMSD timeseries  to file </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">filename</span></div></div>


<div class="viewcode-block" id="RMSF"><a class="viewcode-back" href="../../../documentation_pages/analysis/rms.html#MDAnalysis.analysis.rms.RMSF">[docs]</a><span class="k">class</span> <span class="nc">RMSF</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class to perform RMSF analysis on a set of atoms across a trajectory.</span>

<span class="sd">    Run the analysis with :meth:`RMSF.run`, which stores the results</span>
<span class="sd">    in the array :attr:`RMSF.rmsf`.</span>

<span class="sd">    This class performs no coordinate transforms; RMSFs are obtained from atom</span>
<span class="sd">    coordinates as-is.</span>

<span class="sd">    .. versionadded:: 0.11.0</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atomgroup</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate RMSF of given atoms across a trajectory.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atomgroup : mda.AtomGroup</span>
<span class="sd">                AtomGroup to obtain RMSF for</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atomgroup</span> <span class="o">=</span> <span class="n">atomgroup</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rmsf</span> <span class="o">=</span> <span class="bp">None</span>

<div class="viewcode-block" id="RMSF.run"><a class="viewcode-back" href="../../../documentation_pages/analysis/rms.html#MDAnalysis.analysis.rms.RMSF.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">progout</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate RMSF of given atoms across a trajectory.</span>

<span class="sd">        This method implements an algorithm for computing sums of squares while</span>
<span class="sd">        avoiding overflows and underflows [Welford1962]_.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : int (optional)</span>
<span class="sd">            starting frame, default None becomes 0.</span>
<span class="sd">        stop : int (optional)</span>
<span class="sd">            Frame index to stop analysis. Default: None becomes</span>
<span class="sd">            n_frames. Iteration stops *before* this frame number,</span>
<span class="sd">            which means that the trajectory would be read until the end.</span>
<span class="sd">        step : int (optional)</span>
<span class="sd">            step between frames, default None becomes 1.</span>
<span class="sd">        progout : int (optional)</span>
<span class="sd">            number of frames to iterate through between updates to progress</span>
<span class="sd">            output; ``None`` for no updates [10]</span>
<span class="sd">        quiet : bool (optional)</span>
<span class="sd">            if ``True``, suppress all output (implies *progout* = ``None``)</span>
<span class="sd">            [``False``]</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [Welford1962] B. P. Welford (1962). &quot;Note on a Method for</span>
<span class="sd">           Calculating Corrected Sums of Squares and Products.&quot; Technometrics</span>
<span class="sd">           4(3):419-420.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">traj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomgroup</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">check_slice_indices</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="n">sumsquares</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">atomgroup</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sumsquares</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">quiet</span><span class="p">:</span>
            <span class="n">progout</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c1"># set up progress output</span>
        <span class="k">if</span> <span class="n">progout</span><span class="p">:</span>
            <span class="n">percentage</span> <span class="o">=</span> <span class="n">ProgressMeter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atomgroup</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">n_frames</span><span class="p">,</span>
                                       <span class="n">interval</span><span class="o">=</span><span class="n">progout</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">percentage</span> <span class="o">=</span> <span class="n">ProgressMeter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atomgroup</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">n_frames</span><span class="p">,</span>
                                       <span class="n">quiet</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">ts</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atomgroup</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">:</span><span class="n">step</span><span class="p">]):</span>
            <span class="n">sumsquares</span> <span class="o">+=</span> <span class="p">(</span><span class="n">k</span><span class="o">/</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atomgroup</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="n">means</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">means</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="n">means</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomgroup</span><span class="o">.</span><span class="n">positions</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="n">percentage</span><span class="o">.</span><span class="n">echo</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">frame</span><span class="p">)</span>

        <span class="n">rmsf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sumsquares</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">rmsf</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Some RMSF values negative; overflow &quot;</span> <span class="o">+</span>
                             <span class="s2">&quot;or underflow occurred&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_rmsf</span> <span class="o">=</span> <span class="n">rmsf</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rmsf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;RMSF data; only available after using :meth:`RMSF.run`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rmsf</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">MDAnalysis 0.15.1-dev0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2005-2015, Naveen Michaud-Agrawal, Elizabeth J. Denning, Christian Beckstein (logo), Joshua L. Adelman, Balasubramanian, Jonathan Barnoud, Alejandro Bernardin, Bart Bruininks, Sébastien Buchoux, David Caplan, Matthieu Chavent, Robert Delgado, John Detlefs, Xavier Deupi, Jan Domanski, David L. Dotson, Lennard van der Feltz, Philip Fowler, Joseph Goose, Richard J. Gowers, Lukas Grossar, Abhinav Gupta, Benjamin Hall, Eugen Hruska, Kyle J. Huston, Joe Jordan, Max Linke, Jinju Lu, Robert McGibbon, Manuel Nuno Melo, Fiona Naughton, Alex Nesterenko, Hai Nguyen, Mattia F. Palermo, Danny Parton, Joshua L. Phillips, Tyler Reddy, Paul Rigor, Carlos Yanez S., Utkarsh Saxena, Sean L. Seyler, Andy Somogyi, Caio S. Souza, Lukas Stelzl, Gorman Stock, Isaac Virshup, Zhuyi Xue, and Oliver Beckstein.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.5.
    </div>
  </body>
</html>