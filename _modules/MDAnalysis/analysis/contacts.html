<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>MDAnalysis.analysis.contacts &mdash; MDAnalysis 0.16.0-dev0 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.16.0-dev0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 0.16.0-dev0 documentation"
          href="../../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../../_static/mdanalysis-logo.ico"/>
    <link rel="top" title="MDAnalysis 0.16.0-dev0 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">MDAnalysis 0.16.0-dev0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/mdanalysis-logo-200x150.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for MDAnalysis.analysis.contacts</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-</span>
<span class="c1"># vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4</span>
<span class="c1">#</span>
<span class="c1"># MDAnalysis --- http://www.MDAnalysis.org</span>
<span class="c1"># Copyright (c) 2006-2015 Naveen Michaud-Agrawal, Elizabeth J. Denning, Oliver</span>
<span class="c1"># Beckstein and contributors (see AUTHORS for the full list)</span>
<span class="c1">#</span>
<span class="c1"># Released under the GNU Public Licence, v2 or any higher version</span>
<span class="c1">#</span>
<span class="c1"># Please cite your use of MDAnalysis in published work:</span>
<span class="c1">#</span>
<span class="c1"># N. Michaud-Agrawal, E. J. Denning, T. B. Woolf, and O. Beckstein.</span>
<span class="c1"># MDAnalysis: A Toolkit for the Analysis of Molecular Dynamics Simulations.</span>
<span class="c1"># J. Comput. Chem. 32 (2011), 2319--2327, doi:10.1002/jcc.21787</span>
<span class="c1">#</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">================================================================</span>
<span class="sd">Native contacts analysis --- :mod:`MDAnalysis.analysis.contacts`</span>
<span class="sd">================================================================</span>


<span class="sd">Analysis of native contacts *Q* over a trajectory. Native contacts of a</span>
<span class="sd">conformation are contacts that exist in a reference structure and in the</span>
<span class="sd">conformation. Contacts in the reference structure are always defined as being</span>
<span class="sd">closer then a distance `radius`. The fraction of native contacts for a</span>
<span class="sd">conformation can be calculated in different ways. This module supports 3</span>
<span class="sd">different metrics liseted below, as wel as custom metrics.</span>

<span class="sd">1. *Hard Cut*: To count as a contact the atoms *i* and *j* have to be at least</span>
<span class="sd">   as close as in the reference structure.</span>

<span class="sd">2. *Soft Cut*: The atom pair *i* and *j* is assigned based on a soft potential</span>
<span class="sd">   that is 1 for if the distance is 0, 1/2 if the distance is the same as in</span>
<span class="sd">   the reference and 0 for large distances. For the exact definition of the</span>
<span class="sd">   potential and parameters have a look at function :func:`soft_cut_q`.</span>

<span class="sd">3. *Radius Cut*: To count as a contact the atoms *i* and *j* cannot be further</span>
<span class="sd">   apart then some distance `radius`.</span>

<span class="sd">The &quot;fraction of native contacts&quot; *Q(t)* is a number between 0 and 1 and</span>
<span class="sd">calculated as the total number of native contacts for a given time frame</span>
<span class="sd">divided by the total number of contacts in the reference structure.</span>


<span class="sd">Examples for contact analysis</span>
<span class="sd">-----------------------------</span>

<span class="sd">One-dimensional contact analysis</span>
<span class="sd">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

<span class="sd">As an example we analyze the opening (&quot;unzipping&quot;) of salt bridges</span>
<span class="sd">when the AdK enzyme opens up; this is one of the example trajectories</span>
<span class="sd">in MDAnalysis. ::</span>

<span class="sd">    import MDAnalysis as mda</span>
<span class="sd">    from MDAnalysis.analysis import contacts</span>
<span class="sd">    from MDAnalysis.tests.datafiles import PSF,DCD</span>
<span class="sd">    import matplotlib.pyplot as plt</span>
<span class="sd">    # example trajectory (transition of AdK from closed to open)</span>
<span class="sd">    u = mda.Universe(PSF,DCD)</span>
<span class="sd">    # crude definition of salt bridges as contacts between NH/NZ in ARG/LYS and</span>
<span class="sd">    # OE*/OD* in ASP/GLU. You might want to think a little bit harder about the</span>
<span class="sd">    # problem before using this for real work.</span>
<span class="sd">    sel_basic = &quot;(resname ARG LYS) and (name NH* NZ)&quot;</span>
<span class="sd">    sel_acidic = &quot;(resname ASP GLU) and (name OE* OD*)&quot;</span>
<span class="sd">    # reference groups (first frame of the trajectory, but you could also use a</span>
<span class="sd">    # separate PDB, eg crystal structure)</span>
<span class="sd">    acidic = u.select_atoms(sel_acidic)</span>
<span class="sd">    basic = u.select_atoms(sel_basic)</span>
<span class="sd">    # set up analysis of native contacts (&quot;salt bridges&quot;); salt bridges have a</span>
<span class="sd">    # distance &lt;6 A</span>
<span class="sd">    ca1 = contacts.Contacts(u, selection=(sel_acidic, sel_basic),</span>
<span class="sd">                            refgroup=(acidic, basic), radius=6.0)</span>
<span class="sd">    # iterate through trajectory and perform analysis of &quot;native contacts&quot; Q</span>
<span class="sd">    ca1.run()</span>
<span class="sd">    # print number of averave contacts</span>
<span class="sd">    average_contacts = np.mean(ca1.timeseries[:, 1])</span>
<span class="sd">    print(&#39;average contacts = {}&#39;.format(average_contacts))</span>
<span class="sd">    # plot time series q(t)</span>
<span class="sd">    f, ax = plt.subplots()</span>
<span class="sd">    ax.plot(ca1.timeseries[:, 0], ca1.timeseries[:, 1])</span>
<span class="sd">    ax.set(xlabel=&#39;frame&#39;, ylabel=&#39;fraction of native contacts&#39;,</span>
<span class="sd">           title=&#39;Native Contacts, average = {:.2f}&#39;.format(average_contacts))</span>
<span class="sd">    fig.show()</span>


<span class="sd">The first graph shows that when AdK opens, about 20% of the salt</span>
<span class="sd">bridges that existed in the closed state disappear when the enzyme</span>
<span class="sd">opens. They open in a step-wise fashion (made more clear by the movie</span>
<span class="sd">`AdK_zipper_cartoon.avi`_).</span>

<span class="sd">.. _`AdK_zipper_cartoon.avi`:</span>
<span class="sd">   http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2803350/bin/NIHMS150766-supplement-03.avi</span>

<span class="sd">.. rubric:: Notes</span>

<span class="sd">Suggested cutoff distances for different simulations</span>

<span class="sd">* For all-atom simulations, cutoff = 4.5 Å</span>
<span class="sd">* For coarse-grained simulations, cutoff = 6.0 Å</span>


<span class="sd">Two-dimensional contact analysis (q1-q2)</span>
<span class="sd">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

<span class="sd">Analyze a single DIMS transition of AdK between its closed and open</span>
<span class="sd">conformation and plot the trajectory projected on q1-q2 [Franklin2007]_ ::</span>


<span class="sd">    import MDAnalysis as mda</span>
<span class="sd">    from MDAnalysis.analysis import contacts</span>
<span class="sd">    from MDAnalysisTests.datafiles import PSF, DCD</span>
<span class="sd">    u = mda.Universe(PSF, DCD)</span>
<span class="sd">    q1q2 = contacts.q1q2(u, &#39;name CA&#39;, radius=8)</span>
<span class="sd">    q1q2.run()</span>

<span class="sd">    f, ax = plt.subplots(1, 2, figsize=plt.figaspect(0.5))</span>
<span class="sd">    ax[0].plot(q1q2.timeseries[:, 0], q1q2.timeseries[:, 1], label=&#39;q1&#39;)</span>
<span class="sd">    ax[0].plot(q1q2.timeseries[:, 0], q1q2.timeseries[:, 2], label=&#39;q2&#39;)</span>
<span class="sd">    ax[0].legend(loc=&#39;best&#39;)</span>
<span class="sd">    ax[1].plot(q1q2.timeseries[:, 1], q1q2.timeseries[:, 2], &#39;.-&#39;)</span>
<span class="sd">    f.show()</span>

<span class="sd">Compare the resulting pathway to the `MinActionPath result for AdK`_</span>
<span class="sd">[Franklin2007]_.</span>

<span class="sd">.. _MinActionPath result for AdK:</span>
<span class="sd">   http://lorentz.dynstr.pasteur.fr/joel/adenylate.php</span>


<span class="sd">Writing your own contact analysis</span>
<span class="sd">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

<span class="sd">The :class:`Contacts` class has been designed to be extensible for your own</span>
<span class="sd">analysis. As an example we will analysis when the acidic and basic groups of</span>
<span class="sd">are in contact which each other, this means that at least one of the contacts</span>
<span class="sd">formed in the reference is closer then 2.5 Å.</span>

<span class="sd">For this we define a new function to determine if any contact is closer than</span>
<span class="sd">2.5 Å; this function must implement the API prescribed by :class:`Contacts`::</span>

<span class="sd">    def is_any_closer(r, r0, dist=2.5):</span>
<span class="sd">        return np.any(r &lt; dist)</span>

<span class="sd">The first two parameters `r` and `r0` are provided by :class:`Contacts` when it</span>
<span class="sd">calls :func:`is_any_closer` while the others can be passed as keyword args</span>
<span class="sd">using the `kwargs` parameter in :class:`Contacts`.</span>

<span class="sd">Next we are creating an instance of the :class:`Contacts` class and use the</span>
<span class="sd">:func:`is_any_closer` function as an argument to `method` and run the analysis::</span>

<span class="sd">    # crude definition of salt bridges as contacts between NH/NZ in ARG/LYS and</span>
<span class="sd">    # OE*/OD* in ASP/GLU. You might want to think a little bit harder about the</span>
<span class="sd">    # problem before using this for real work.</span>
<span class="sd">    sel_basic = &quot;(resname ARG LYS) and (name NH* NZ)&quot;</span>
<span class="sd">    sel_acidic = &quot;(resname ASP GLU) and (name OE* OD*)&quot;</span>

<span class="sd">    # reference groups (first frame of the trajectory, but you could also use a</span>
<span class="sd">    # separate PDB, eg crystal structure)</span>
<span class="sd">    acidic = u.select_atoms(sel_acidic)</span>
<span class="sd">    basic = u.select_atoms(sel_basic)</span>

<span class="sd">    nc = contacts.Contacts(u, selection=(sel_acidic, sel_basic),</span>
<span class="sd">                           method=is_any_closer,</span>
<span class="sd">                           refgroup=(acidic, basic), kwargs={&#39;dist&#39;: 2.5})</span>
<span class="sd">    nc.run()</span>

<span class="sd">    bound = nc.timeseries[:, 1]</span>
<span class="sd">    frames = nc.timeseries[:, 0]</span>

<span class="sd">    f, ax = plt.subplots()</span>

<span class="sd">    ax.plot(frames, bound, &#39;.&#39;)</span>
<span class="sd">    ax.set(xlabel=&#39;frame&#39;, ylabel=&#39;is Bound&#39;,</span>
<span class="sd">           ylim=(-0.1, 1.1))</span>

<span class="sd">    f.show()</span>


<span class="sd">Functions</span>
<span class="sd">---------</span>

<span class="sd">.. autofunction:: hard_cut_q</span>
<span class="sd">.. autofunction:: soft_cut_q</span>
<span class="sd">.. autofunction:: radius_cut_q</span>
<span class="sd">.. autofunction:: contact_matrix</span>
<span class="sd">.. autofunction:: q1q2</span>

<span class="sd">Classes</span>
<span class="sd">-------</span>

<span class="sd">.. autoclass:: Contacts</span>
<span class="sd">   :members:</span>


<span class="sd">Deprecated</span>
<span class="sd">----------</span>

<span class="sd">The following classes are deprecated and are scheduled for removal in release 0.17.0.</span>

<span class="sd">.. autoclass:: ContactAnalysis1</span>
<span class="sd">   :members:</span>
<span class="sd">.. autoclass:: ContactAnalysis</span>
<span class="sd">   :members:</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">errno</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">bz2</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="kn">import</span> <span class="nb">zip</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy.lib.utils</span> <span class="kn">import</span> <span class="n">deprecate</span>

<span class="kn">import</span> <span class="nn">logging</span>

<span class="kn">import</span> <span class="nn">MDAnalysis</span>
<span class="kn">import</span> <span class="nn">MDAnalysis.lib.distances</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.lib.util</span> <span class="kn">import</span> <span class="n">openany</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.analysis.distances</span> <span class="kn">import</span> <span class="n">distance_array</span>
<span class="kn">from</span> <span class="nn">MDAnalysis.core.AtomGroup</span> <span class="kn">import</span> <span class="n">AtomGroup</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="kn">import</span> <span class="n">AnalysisBase</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;MDAnalysis.analysis.contacts&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="soft_cut_q"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.soft_cut_q">[docs]</a><span class="k">def</span> <span class="nf">soft_cut_q</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span> <span class="n">lambda_constant</span><span class="o">=</span><span class="mf">1.8</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Calculate fraction of native contacts *Q* for a soft cut off</span>

<span class="sd">    The native contact function is defined as [Best2013]_</span>

<span class="sd">    .. math::</span>

<span class="sd">        Q(r, r_0) = \frac{1}{1 + e^{\beta (r - \lambda r_0)}}</span>

<span class="sd">    Reasonable values for different simulation types are</span>

<span class="sd">    - *All Atom*: `lambda_constant = 1.8` (unitless)</span>
<span class="sd">    - *Coarse Grained*: `lambda_constant = 1.5` (unitless)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    r: array</span>
<span class="sd">      Contact distances at time t</span>
<span class="sd">    r0: array</span>
<span class="sd">      Contact distances at time t=0, reference distances</span>
<span class="sd">    beta: float (default 5.0 Angstrom)</span>
<span class="sd">      Softness of the switching function</span>
<span class="sd">    lambda_constant: float (default 1.8, unitless)</span>
<span class="sd">      Reference distance tolerance</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Q : float</span>
<span class="sd">      fraction of native contacts</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [Best2013] RB Best, G Hummer, and WA Eaton, &quot;Native contacts determine protein</span>
<span class="sd">       folding mechanisms in atomistic simulations&quot; _PNAS_ **110** (2013),</span>
<span class="sd">       17874–17879. doi: `10.1073/pnas.1311599110</span>
<span class="sd">       &lt;http://doi.org/10.1073/pnas.1311599110&gt;`_.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">r0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">r0</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">beta</span><span class="o">*</span><span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">lambda_constant</span> <span class="o">*</span> <span class="n">r0</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">r0</span><span class="p">)</span></div>


<div class="viewcode-block" id="hard_cut_q"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.hard_cut_q">[docs]</a><span class="k">def</span> <span class="nf">hard_cut_q</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate fraction of native contacts *Q* for a hard cut off.</span>

<span class="sd">    The cutoff can either be a float or a :class:`~numpy.ndarray` of the same</span>
<span class="sd">    shape as `r`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    r : ndarray</span>
<span class="sd">        distance matrix</span>
<span class="sd">    cutoff : ndarray | float</span>
<span class="sd">        cut off value to count distances. Can either be a float of a ndarray of</span>
<span class="sd">        the same size as distances</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Q : float</span>
<span class="sd">        fraction of contacts</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">cutoff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">cutoff</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">cutoff</span>
    <span class="k">return</span> <span class="n">y</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">r</span><span class="o">.</span><span class="n">size</span></div>


<div class="viewcode-block" id="radius_cut_q"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.radius_cut_q">[docs]</a><span class="k">def</span> <span class="nf">radius_cut_q</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="n">radius</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;calculate native contacts *Q* based on the single distance radius.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    r : ndarray</span>
<span class="sd">        distance array between atoms</span>
<span class="sd">    r0 : ndarray</span>
<span class="sd">        unused to fullfill :class:`Contacts` API</span>
<span class="sd">    radius : float</span>
<span class="sd">        Distance between atoms at which a contact is formed</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Q : float</span>
<span class="sd">        fraction of contacts</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [Franklin2007] Franklin, J., Koehl, P., Doniach, S., &amp; Delarue,</span>
<span class="sd">       M. (2007).  MinActionPath: Maximum likelihood trajectory for large-scale</span>
<span class="sd">       structural transitions in a coarse-grained locally harmonic energy</span>
<span class="sd">       landscape.  Nucleic Acids Research, 35(SUPPL.2), 477–482.</span>
<span class="sd">       doi: `10.1093/nar/gkm342 &lt;http://doi.org/10.1093/nar/gkm342&gt;`_</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">hard_cut_q</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">radius</span><span class="p">)</span></div>


<div class="viewcode-block" id="contact_matrix"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.contact_matrix">[docs]</a><span class="k">def</span> <span class="nf">contact_matrix</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;calculate contacts from distance matrix</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d : array-like</span>
<span class="sd">        distance matrix</span>
<span class="sd">    radius : float</span>
<span class="sd">        distance below which a contact is formed.</span>
<span class="sd">    out: array (optional)</span>
<span class="sd">        If `out` is supplied as a pre-allocated array of the correct</span>
<span class="sd">        shape then it is filled instead of allocating a new one in</span>
<span class="sd">        order to increase performance.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    contacts : ndarray</span>
<span class="sd">        boolean array of formed contacts</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">out</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">d</span> <span class="o">&lt;=</span> <span class="n">radius</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">d</span> <span class="o">&lt;=</span> <span class="n">radius</span>
    <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="Contacts"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.Contacts">[docs]</a><span class="k">class</span> <span class="nc">Contacts</span><span class="p">(</span><span class="n">AnalysisBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate contacts based observables.</span>

<span class="sd">    The standard methods used in this class calculate the fraction of native</span>
<span class="sd">    contacts *Q* from a trajectory.</span>


<span class="sd">    .. rubric:: Contact API</span>

<span class="sd">    By defining your own method it is possible to calculate other observables</span>
<span class="sd">    that only depend on the distances and a possible reference distance. The</span>
<span class="sd">    **Contact API** prescribes that this method must be a function with call</span>
<span class="sd">    signature ``func(r, r0, **kwargs)`` and must be provided in the keyword</span>
<span class="sd">    argument `method`.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    timeseries : list</span>
<span class="sd">        list containing *Q* for all refgroup pairs and analyzed frames</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">selection</span><span class="p">,</span> <span class="n">refgroup</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;hard_cut&quot;</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mf">4.5</span><span class="p">,</span>
                 <span class="n">kwargs</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">basekwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        u : Universe</span>
<span class="sd">            trajectory</span>
<span class="sd">        selection : tuple(string, string)</span>
<span class="sd">            two contacting groups that change over time</span>
<span class="sd">        refgroup : tuple(AtomGroup, AtomGroup)</span>
<span class="sd">            two contacting atomgroups in their reference conformation. This</span>
<span class="sd">            can also be a list of tuples containing different atom groups</span>
<span class="sd">        radius : float, optional (4.5 Angstroms)</span>
<span class="sd">            radius within which contacts exist in refgroup</span>
<span class="sd">        method : string | callable (optional)</span>
<span class="sd">            Can either be one of ``[&#39;hard_cut&#39; , &#39;soft_cut&#39;]`` or a callable</span>
<span class="sd">            with call signature ``func(r, r0, **kwargs)`` (the &quot;Contacts API&quot;).</span>
<span class="sd">        kwargs : dict, optional</span>
<span class="sd">            dictionary of additional kwargs passed to `method`. Check</span>
<span class="sd">            respective functions for reasonable values.</span>
<span class="sd">        start : int, optional</span>
<span class="sd">            First frame of trajectory to analyse, Default: None becomes 0.</span>
<span class="sd">        stop : int, optional</span>
<span class="sd">            Frame index to stop analysis. Default: None becomes</span>
<span class="sd">            n_frames. Iteration stops *before* this frame number,</span>
<span class="sd">            which means that the trajectory would be read until the end.</span>
<span class="sd">        step : int, optional</span>
<span class="sd">            Step between frames to analyse, Default: None becomes 1.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="n">u</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Contacts</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">,</span> <span class="o">**</span><span class="n">basekwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;hard_cut&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fraction_contacts</span> <span class="o">=</span> <span class="n">hard_cut_q</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;soft_cut&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fraction_contacts</span> <span class="o">=</span> <span class="n">soft_cut_q</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;method has to be callable&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fraction_contacts</span> <span class="o">=</span> <span class="n">method</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">selection</span> <span class="o">=</span> <span class="n">selection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grA</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">selection</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grB</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">selection</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># contacts formed in reference</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r0</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_contacts</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">refgroup</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">AtomGroup</span><span class="p">):</span>
            <span class="n">refA</span><span class="p">,</span> <span class="n">refB</span> <span class="o">=</span> <span class="n">refgroup</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">r0</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">distance_array</span><span class="p">(</span><span class="n">refA</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span> <span class="n">refB</span><span class="o">.</span><span class="n">positions</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initial_contacts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">contact_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">r0</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">radius</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">refA</span><span class="p">,</span> <span class="n">refB</span> <span class="ow">in</span> <span class="n">refgroup</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">r0</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">distance_array</span><span class="p">(</span><span class="n">refA</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span> <span class="n">refB</span><span class="o">.</span><span class="n">positions</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">initial_contacts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">contact_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">r0</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                                            <span class="n">radius</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fraction_kwargs</span> <span class="o">=</span> <span class="n">kwargs</span> <span class="k">if</span> <span class="n">kwargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">_single_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># compute distance array for a frame</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">distance_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grA</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grB</span><span class="o">.</span><span class="n">positions</span><span class="p">)</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">r0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ts</span><span class="o">.</span><span class="n">frame</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">initial_contacts</span><span class="p">,</span> <span class="n">r0</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_contacts</span><span class="p">,</span>
                                                       <span class="bp">self</span><span class="o">.</span><span class="n">r0</span><span class="p">)):</span>
            <span class="c1"># select only the contacts that were formed in the reference state</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">initial_contacts</span><span class="p">]</span>
            <span class="n">r0</span> <span class="o">=</span> <span class="n">r0</span><span class="p">[</span><span class="n">initial_contacts</span><span class="p">]</span>
            <span class="n">y</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fraction_contacts</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">fraction_kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_conclude</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

<div class="viewcode-block" id="Contacts.save"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.Contacts.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outfile</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;save contacts timeseries</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        outfile : str</span>
<span class="sd">            file to save contacts</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;# q1 analysis</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span><span class="p">)</span></div></div>


<span class="k">def</span> <span class="nf">_new_selections</span><span class="p">(</span><span class="n">u_orig</span><span class="p">,</span> <span class="n">selections</span><span class="p">,</span> <span class="n">frame</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;create stand alone AGs from selections at frame&quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">Universe</span><span class="p">(</span><span class="n">u_orig</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">u_orig</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="n">frame</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">selections</span><span class="p">]</span>


<div class="viewcode-block" id="q1q2"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.q1q2">[docs]</a><span class="k">def</span> <span class="nf">q1q2</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">selection</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mf">4.5</span><span class="p">,</span>
         <span class="n">start</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Perform a q1-q2 analysis.</span>

<span class="sd">    Compares native contacts between the starting structure and final structure</span>
<span class="sd">    of a trajectory [Franklin2007]_.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : Universe</span>
<span class="sd">        Universe with a trajectory</span>
<span class="sd">    selection : string, optional</span>
<span class="sd">        atoms to do analysis on</span>
<span class="sd">    radius : float, optional</span>
<span class="sd">        distance at which contact is formed</span>
<span class="sd">    start : int, optional</span>
<span class="sd">        First frame of trajectory to analyse, Default: 0</span>
<span class="sd">    stop : int, optional</span>
<span class="sd">        Last frame of trajectory to analyse, Default: -1</span>
<span class="sd">    step : int, optional</span>
<span class="sd">        Step between frames to analyse, Default: 1</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    contacts : :class:`Contacts`</span>
<span class="sd">        Contact Analysis that is set up for a q1-q2 analysis</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">selection</span> <span class="o">=</span> <span class="p">(</span><span class="n">selection</span><span class="p">,</span> <span class="n">selection</span><span class="p">)</span>
    <span class="n">first_frame_refs</span> <span class="o">=</span> <span class="n">_new_selections</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">selection</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">last_frame_refs</span> <span class="o">=</span> <span class="n">_new_selections</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">selection</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Contacts</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">selection</span><span class="p">,</span>
                    <span class="p">(</span><span class="n">first_frame_refs</span><span class="p">,</span> <span class="n">last_frame_refs</span><span class="p">),</span>
                    <span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">radius_cut_q</span><span class="p">,</span>
                    <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">,</span>
                    <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;radius&#39;</span><span class="p">:</span> <span class="n">radius</span><span class="p">})</span></div>

<span class="c1">################################################################################</span>
<span class="c1">################################################################################</span>
<span class="c1">################################################################################</span>
<span class="c1">################################################################################</span>
<span class="c1">################################################################################</span>
<span class="c1">################################################################################</span>


<span class="c1"># What comes now are old deprecated contact Analysis classes</span>


<span class="c1"># ContactAnalysis needs to be cleaned up and possibly renamed but</span>
<span class="c1"># until then it remains because we don&#39;t have the functionality</span>
<span class="c1"># elsewhere.</span>

<span class="nd">@deprecate</span><span class="p">(</span><span class="n">new_name</span><span class="o">=</span><span class="s2">&quot;Contacts&quot;</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;This class will be removed in 0.17&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">ContactAnalysis</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Perform a native contact analysis (&quot;q1-q2&quot;).</span>

<span class="sd">    The analysis of the trajectory is performed with the</span>
<span class="sd">    :meth:`ContactAnalysis.run` method. The result is stored in</span>
<span class="sd">    :attr:`ContactAnalysis.timeseries`. It is a numpy array which</span>
<span class="sd">    contains the frame number at index 0, q1 and q2 at index 1 and 2,</span>
<span class="sd">    and the total number of contacts in 3 and 4. ::</span>

<span class="sd">        frame  q1 q2  n1 n2</span>

<span class="sd">    The total number of contacts in the reference states 1 and 2 are</span>
<span class="sd">    stored in :attr:`ContactAnalysis.nref` (index 0 and 1).</span>

<span class="sd">    The :meth:`ContactAnalysis.run` method calculates the percentage of native</span>
<span class="sd">    contacts *q1* and *q2* along a trajectory. &quot;Contacts&quot; are defined as the</span>
<span class="sd">    number of Ca atoms (or per-residue *centroids* of a user defined</span>
<span class="sd">    *selection*) within *radius* of a primary Ca. *q1* is the fraction of</span>
<span class="sd">    contacts relative to the reference state 1 (typically the starting</span>
<span class="sd">    conformation of the trajectory) and *q2* is the fraction of contacts</span>
<span class="sd">    relative to the conformation 2.</span>

<span class="sd">    The timeseries is written to a bzip2-compressed file in `targetdir`</span>
<span class="sd">    named &quot;basename(trajectory)infix_q1q2.dat.bz2&quot; and is also</span>
<span class="sd">    accessible as the attribute</span>
<span class="sd">    :attr:`ContactAnalysis.timeseries`.</span>


<span class="sd">    .. deprecated:: 0.15.0</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">topology</span><span class="p">,</span> <span class="n">trajectory</span><span class="p">,</span> <span class="n">ref1</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ref2</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mf">8.0</span><span class="p">,</span>
                 <span class="n">targetdir</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">curdir</span><span class="p">,</span> <span class="n">infix</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">selection</span><span class="o">=</span><span class="s2">&quot;name CA&quot;</span><span class="p">,</span> <span class="n">centroids</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        topology : filename as str</span>
<span class="sd">            topology file</span>
<span class="sd">        trajectory : filename as str</span>
<span class="sd">            trajectory</span>
<span class="sd">        ref1 : filename or ``None``, optional</span>
<span class="sd">            structure of the reference conformation 1 (pdb); if ``None`` the</span>
<span class="sd">            *first* frame of the trajectory is chosen</span>
<span class="sd">        ref2 : filename or ``None``, optional</span>
<span class="sd">            structure of the reference conformation 2 (pdb); if ``None`` the</span>
<span class="sd">            *last* frame of the trajectory is chosen</span>
<span class="sd">        radius : float, optional, default 8 A</span>
<span class="sd">            contacts are deemed any Ca within radius</span>
<span class="sd">        targetdir : path, optional, default ``.``</span>
<span class="sd">            output files are saved in this directory</span>
<span class="sd">        infix : string, optional</span>
<span class="sd">            additional tag string that is inserted into the output filename of</span>
<span class="sd">            the data file</span>
<span class="sd">         selection : string, optional, default ``&quot;name CA&quot;``</span>
<span class="sd">            MDAnalysis selection string that selects the particles of</span>
<span class="sd">            interest; the default is to only select the C-alpha atoms</span>
<span class="sd">            in `ref1` and `ref2`</span>

<span class="sd">            .. Note:: If `selection` produces more than one atom per</span>
<span class="sd">                      residue then you will get multiple contacts per</span>
<span class="sd">                      residue unless you also set `centroids` = ``True``</span>
<span class="sd">         centroids : bool</span>
<span class="sd">            If set to ``True``, use the centroids for the selected atoms on a</span>
<span class="sd">            per-residue basis to compute contacts. This allows, for instance</span>
<span class="sd">            defining the sidechains as `selection` and then computing distances</span>
<span class="sd">            between sidechain centroids.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">topology</span> <span class="o">=</span> <span class="n">topology</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trajectory</span> <span class="o">=</span> <span class="n">trajectory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">targetdir</span> <span class="o">=</span> <span class="n">targetdir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">force</span> <span class="o">=</span> <span class="n">force</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection</span> <span class="o">=</span> <span class="n">selection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">centroids</span> <span class="o">=</span> <span class="n">centroids</span>

        <span class="n">trajectorybase</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">trajectory</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">trajectorybase</span> <span class="o">+</span> <span class="n">infix</span> <span class="o">+</span> <span class="s1">&#39;_q1q2.dat&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetdir</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_bz2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output</span> <span class="o">+</span> <span class="s1">&#39;.bz2&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c1"># final result</span>

        <span class="c1"># short circuit if output file already exists: skip everything</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_exists</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_skip</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="c1"># do not bother reading any data or initializing arrays... !!</span>
            <span class="k">return</span>

        <span class="c1"># don&#39;t bother if trajectory is empty (can lead to segfaults so better</span>
        <span class="c1"># catch it)</span>
        <span class="n">stats</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">trajectory</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">stats</span><span class="o">.</span><span class="n">st_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;trajectory = {trajectory!s} is empty, &#39;</span>
                          <span class="s1">&#39;skipping...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="nb">vars</span><span class="p">()))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_skip</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">return</span>
        <span class="c1"># under normal circumstances we do not skip</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_skip</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="c1"># expensive initialization starts with building Universes :-)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">Universe</span><span class="p">(</span><span class="n">topology</span><span class="p">,</span> <span class="n">trajectory</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ref1</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ref1</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetdir</span><span class="p">,</span> <span class="n">trajectorybase</span> <span class="o">+</span> <span class="s1">&#39;_first.pdb&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># extract first frame</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ref1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref1</span> <span class="o">=</span> <span class="n">ref1</span>
        <span class="k">if</span> <span class="n">ref2</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ref2</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetdir</span><span class="p">,</span> <span class="n">trajectorybase</span> <span class="o">+</span> <span class="s1">&#39;_last.pdb&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># extract last frame</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ref2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># rewind, just in case...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref2</span> <span class="o">=</span> <span class="n">ref2</span>

        <span class="n">r1</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">Universe</span><span class="p">(</span><span class="n">topology</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref1</span><span class="p">)</span>
        <span class="n">r2</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">Universe</span><span class="p">(</span><span class="n">topology</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref2</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ca</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection</span><span class="p">)</span>
        <span class="n">ca1</span> <span class="o">=</span> <span class="n">r1</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection</span><span class="p">)</span>
        <span class="n">ca2</span> <span class="o">=</span> <span class="n">r2</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection</span><span class="p">)</span>

        <span class="c1"># NOTE: self_distance_array() produces a 1D array; this works here</span>
        <span class="c1">#       but is not the same as the 2D output from distance_array()!</span>
        <span class="c1">#       See the docs for self_distance_array().</span>
        <span class="n">dref</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_distance_array</span><span class="p">(</span><span class="n">ca1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_distance_array</span><span class="p">(</span><span class="n">ca2</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qref</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">qarray</span><span class="p">(</span><span class="n">dref</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">qarray</span><span class="p">(</span><span class="n">dref</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nref</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">qref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">qref</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">dref</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qtmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">)</span>  <span class="c1"># pre-allocated array</span>

<div class="viewcode-block" id="ContactAnalysis.get_distance_array"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis.get_distance_array">[docs]</a>    <span class="k">def</span> <span class="nf">get_distance_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the self_distance_array for atoms in group *g*.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        g : AtomGroup</span>
<span class="sd">              group of atoms to calculate distance array for</span>
<span class="sd">        results : array, optional</span>
<span class="sd">              passed on to :func:`MDAnalysis.lib.distances.self_distance_array`</span>
<span class="sd">              as a preallocated array</span>
<span class="sd">        centroids : bool, optional, default ``None``</span>
<span class="sd">              ``True``: calculate per-residue centroids from the selected</span>
<span class="sd">              atoms; ``False``: consider each atom separately; ``None``: use</span>
<span class="sd">              the class default for *centroids* [``None``]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">centroids</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;centroids&quot;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">centroids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroids</span> <span class="k">if</span> <span class="n">centroids</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">centroids</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">centroids</span><span class="p">:</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">positions</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># centroids per residue (but only including the selected atoms)</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">residue</span><span class="o">.</span><span class="n">centroid</span><span class="p">()</span>
                                    <span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;residue&quot;</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">self_distance_array</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span>
                                                            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="ContactAnalysis.output_exists"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis.output_exists">[docs]</a>    <span class="k">def</span> <span class="nf">output_exists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if default output file already exists.</span>

<span class="sd">        Disable with force=True (will always return False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">)</span> <span class="ow">or</span>
                <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_bz2</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">force</span> <span class="ow">or</span> <span class="n">force</span><span class="p">)</span></div>

<div class="viewcode-block" id="ContactAnalysis.run"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">store</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Analyze trajectory and produce timeseries.</span>

<span class="sd">        Stores results in :attr:`ContactAnalysis.timeseries` (if</span>
<span class="sd">        store=True) and writes them to a bzip2-compressed data file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skip</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_exists</span><span class="p">(</span><span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;File {output!r} or {output_bz2!r} already exists, &quot;</span>
                          <span class="s2">&quot;loading {trajectory!r}.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="nb">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_bz2</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="n">outbz2</span> <span class="o">=</span> <span class="n">bz2</span><span class="o">.</span><span class="n">BZ2File</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_bz2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">buffering</span><span class="o">=</span><span class="mi">8192</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">outbz2</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;# q1-q2 analysis</span><span class="se">\n</span><span class="s2">&quot;</span>
                         <span class="s2">&quot;# nref1 = {0:d}</span><span class="se">\n</span><span class="s2">&quot;</span>
                         <span class="s2">&quot;# nref2 = {1:d}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nref</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">nref</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">outbz2</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;# frame  q1  q2   n1  n2</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">records</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">:</span>
                <span class="n">frame</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">frame</span>
                <span class="c1"># use pre-allocated distance array to save a little bit of time</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_distance_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ca</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">)</span>
                <span class="n">n1</span><span class="p">,</span> <span class="n">q1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qN</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_qtmp</span><span class="p">)</span>
                <span class="n">n2</span><span class="p">,</span> <span class="n">q2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qN</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_qtmp</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">store</span><span class="p">:</span>
                    <span class="n">records</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">frame</span><span class="p">,</span> <span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">))</span>
                <span class="n">outbz2</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;{frame:4d}  {q1:8.6f} {q2:8.6f}  {n1:5d} {n2:5d}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="nb">vars</span><span class="p">()))</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">outbz2</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">store</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">records</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_bz2</span></div>

<div class="viewcode-block" id="ContactAnalysis.qarray"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis.qarray">[docs]</a>    <span class="k">def</span> <span class="nf">qarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return array with ``True`` for contacts.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This method is typically only used internally.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        d : array</span>
<span class="sd">          2D array of distances. The method uses the value of</span>
<span class="sd">          :attr:`radius` to determine if a ``distance &lt; radius``</span>
<span class="sd">          is considered a contact.</span>
<span class="sd">        out : array, optional</span>
<span class="sd">          If `out` is supplied as a pre-allocated array of the correct</span>
<span class="sd">          shape then it is filled instead of allocating a new one in</span>
<span class="sd">          order to increase performance.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array</span>
<span class="sd">           contact matrix</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="ContactAnalysis.qN"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis.qN">[docs]</a>    <span class="k">def</span> <span class="nf">qN</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate native contacts relative to reference state.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This method is typically only used internally.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        q : array</span>
<span class="sd">          contact matrix (see :meth:`Contacts.qarray`)</span>
<span class="sd">        out : array, optional</span>
<span class="sd">          If `out` is supplied as a pre-allocated array of the correct</span>
<span class="sd">          shape then it will contain the contact matrix relative</span>
<span class="sd">          to the reference state, i.e. only those contacts that</span>
<span class="sd">          are also seen in the reference state.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        contacts : integer</span>
<span class="sd">           total number of contacts</span>
<span class="sd">        fraction : float</span>
<span class="sd">           fraction of contacts relative to the reference state</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qref</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qref</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">out</span><span class="p">)</span>
        <span class="n">contacts</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">contacts</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">contacts</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nref</span><span class="p">[</span><span class="n">n</span><span class="p">]</span></div>

<div class="viewcode-block" id="ContactAnalysis.load"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load the data file.&quot;&quot;&quot;</span>
        <span class="n">records</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="n">openany</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">records</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">records</span><span class="p">)</span><span class="o">.</span><span class="n">T</span></div>

<div class="viewcode-block" id="ContactAnalysis.plot"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot q1-q2.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pylab</span> <span class="kn">import</span> <span class="n">plot</span><span class="p">,</span> <span class="n">xlabel</span><span class="p">,</span> <span class="n">ylabel</span>

        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="s1">&#39;black&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No timeseries data; do &quot;</span>
                             <span class="s2">&quot;&#39;ContactAnalysis.run(store=True)&#39; first.&quot;</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span>
        <span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">xlabel</span><span class="p">(</span><span class="s2">r&quot;$q_1$&quot;</span><span class="p">)</span>
        <span class="n">ylabel</span><span class="p">(</span><span class="s2">r&quot;$q_2$&quot;</span><span class="p">)</span></div>


<span class="nd">@deprecate</span><span class="p">(</span><span class="n">new_name</span><span class="o">=</span><span class="s2">&quot;Contacts&quot;</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;This class will be removed in 0.17&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">ContactAnalysis1</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Perform a very flexible native contact analysis with respect to a single</span>
<span class="sd">    reference.</span>

<span class="sd">    This analysis class allows one to calculate the fraction of native contacts</span>
<span class="sd">    *q* between two arbitrary groups of atoms with respect to an arbitrary</span>
<span class="sd">    reference structure. For instance, as a reference one could take a crystal</span>
<span class="sd">    structure of a complex, and as the two groups atoms one selects two</span>
<span class="sd">    molecules A and B in the complex. Then the question to be answered by *q*</span>
<span class="sd">    is, is which percentage of the contacts between A and B persist during the</span>
<span class="sd">    simulation.</span>

<span class="sd">    First prepare :class:`~MDAnalysis.core.AtomGroup.AtomGroup` selections for</span>
<span class="sd">    the reference atoms; this example uses some arbitrary selections::</span>

<span class="sd">      ref = Universe(&#39;crystal.pdb&#39;)</span>
<span class="sd">      refA = ref.select_atoms(&#39;name CA and segid A and resid 6:100&#39;)</span>
<span class="sd">      refB = ref.select_atoms(&#39;name CA and segid B and resid 1:40&#39;)</span>

<span class="sd">    Load the trajectory::</span>

<span class="sd">      u = Universe(topology, trajectory)</span>

<span class="sd">    We then need two selection strings *selA* and *selB* that, when applied as</span>
<span class="sd">    ``u.select_atoms(selA)`` produce a list of atoms that is equivalent to the</span>
<span class="sd">    reference (i.e. ``u.select_atoms(selA)`` must select the same atoms as</span>
<span class="sd">    ``refA`` in this example)::</span>

<span class="sd">      selA = &#39;name CA and resid 1:95&#39;     # corresponds to refA</span>
<span class="sd">      selB = &#39;name CA and resid 150:189&#39;  # corresponds to refB</span>

<span class="sd">    .. Note::</span>

<span class="sd">       It is the user&#39;s responsibility to provide a reference group</span>
<span class="sd">       (or groups) that describe equivalent atoms to the ones selected</span>
<span class="sd">       by *selection*.</span>

<span class="sd">    Now we are ready to set up the analysis::</span>

<span class="sd">      CA1 = ContactAnalysis1(u, selection=(selA,selB), refgroup=(refA,refB),</span>
<span class="sd">                             radius=8.0, outfile=&quot;q.dat&quot;)</span>

<span class="sd">    If the groups do not match in length then a :exc:`ValueError` is raised.</span>

<span class="sd">    The analysis across the whole trajectory is performed with ::</span>

<span class="sd">      CA1.run()</span>

<span class="sd">    Results are saved to *outfile* (``framenumber q N`` per line) and</span>
<span class="sd">    can also be plotted with ::</span>

<span class="sd">      CA1.plot()        # plots the time series q(t)</span>
<span class="sd">      CA1.plot_qavg()   # plots the matrix of average contacts &lt;q&gt;</span>

<span class="sd">    **Description of computed values** in the output file:</span>

<span class="sd">    *N*</span>
<span class="sd">         number of native contacts</span>

<span class="sd">    *q*</span>
<span class="sd">         fraction of native contacts relative to the reference</span>

<span class="sd">    .. deprecated:: 0.15.0</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate native contacts within a group or between two groups.</span>

<span class="sd">        :Arguments:</span>
<span class="sd">          *topology*</span>
<span class="sd">            psf or pdb file</span>
<span class="sd">          *trajectory*</span>
<span class="sd">            dcd or xtc/trr file</span>
<span class="sd">          *universe*</span>
<span class="sd">            instead of a topology/trajectory combination, one can also supply</span>
<span class="sd">            a :class:`MDAnalysis.Universe`</span>

<span class="sd">        :Keywords:</span>
<span class="sd">          *selection*</span>
<span class="sd">            selection string that determines which distances are calculated; if</span>
<span class="sd">            this is a tuple or list with two entries then distances are</span>
<span class="sd">            calculated between these two different groups [&quot;name CA or name</span>
<span class="sd">            B*&quot;]</span>
<span class="sd">          *refgroup*</span>
<span class="sd">            reference group, either a single</span>
<span class="sd">            :class:`~MDAnalysis.core.AtomGroup.AtomGroup` (if there is only a</span>
<span class="sd">            single *selection*) or a list of two such groups. The reference</span>
<span class="sd">            contacts are directly computed from *refgroup* and hence the atoms</span>
<span class="sd">            in the reference group(s) must be equivalent to the ones produced</span>
<span class="sd">            by the *selection* on the input trajectory.</span>
<span class="sd">          *radius*</span>
<span class="sd">            contacts are deemed any atoms within radius [8.0 A]</span>
<span class="sd">          *outfile*</span>
<span class="sd">            name of the output file; with the gz or bz2 suffix, a compressed</span>
<span class="sd">            file is written. The average &lt;q&gt; is written to a second, gzipped</span>
<span class="sd">            file that has the same name with &#39;array&#39; included. E.g. for the</span>
<span class="sd">            default name &quot;q1.dat.gz&quot; the &lt;q&gt; file will be &quot;q1.array.gz&quot;. The</span>
<span class="sd">            format is the matrix in column-row format, i.e. selection 1</span>
<span class="sd">            residues are the columns and selection 2 residues are rows. The</span>
<span class="sd">            file can be read with :func:`np.loadtxt`.  [&quot;q1.dat.gz&quot;]</span>

<span class="sd">        The function calculates the percentage of native contacts q1</span>
<span class="sd">        along a trajectory. &quot;Contacts&quot; are defined as the number of atoms</span>
<span class="sd">        within *radius* of a given other atom. *q1* is the fraction of contacts</span>
<span class="sd">        relative to the reference state 1 (typically the starting conformation</span>
<span class="sd">        of the trajectory).</span>

<span class="sd">        The timeseries is written to a file *outfile* and is also accessible as</span>
<span class="sd">        the attribute :attr:`ContactAnalysis1.timeseries`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># XX or should I use as input</span>
        <span class="c1">#   sel = (group1, group2), ref = (refgroup1, refgroup2)</span>
        <span class="c1"># and get the universe from sel?</span>
        <span class="c1"># Currently it&#39;s a odd hybrid.</span>
        <span class="c1">#</span>
        <span class="c1"># Enhancements:</span>
        <span class="c1"># - select contact pairs to write out as a timecourse</span>
        <span class="c1"># - make this selection based on qavg</span>
        <span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">splitext</span>

        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;ContactAnalysis1 is deprecated and will be removed &quot;</span>
                      <span class="s2">&quot;in 1.0. Use Contacts instead.&quot;</span><span class="p">,</span>
                      <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">selection_strings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_return_tuple2</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span>
            <span class="s1">&#39;selection&#39;</span><span class="p">,</span> <span class="s2">&quot;name CA or name B*&quot;</span><span class="p">),</span> <span class="s2">&quot;selection&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">references</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_return_tuple2</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;refgroup&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
                                              <span class="s2">&quot;refgroup&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;radius&#39;</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">targetdir</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;targetdir&#39;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">curdir</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;outfile&#39;</span><span class="p">,</span> <span class="s2">&quot;q1.dat.gz&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outarray</span> <span class="o">=</span> <span class="n">splitext</span><span class="p">(</span><span class="n">splitext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">)[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;.array.gz&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">force</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;force&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c1"># final result</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">filenames</span> <span class="o">=</span> <span class="n">args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">universe</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">as_Universe</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">selections</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                           <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection_strings</span><span class="p">]</span>

        <span class="c1"># sanity checkes</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">references</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;a reference AtomGroup must be supplied&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ref</span><span class="p">,</span> <span class="n">sel</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">references</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">selections</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">selection_strings</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ref</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">n_atoms</span> <span class="o">!=</span> <span class="n">sel</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;selection=</span><span class="si">%r</span><span class="s2">: Number of atoms differ &quot;</span>
                                 <span class="s2">&quot;between reference (</span><span class="si">%d</span><span class="s2">) and trajectory (</span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span>
                                 <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ref</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span> <span class="n">sel</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">))</span>

        <span class="c1"># compute reference contacts</span>
        <span class="n">dref</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">distance_array</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">references</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">references</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qarray</span><span class="p">(</span><span class="n">dref</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qref</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="c1"># setup arrays for the trajectory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">dref</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qtmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">)</span>  <span class="c1"># pre-allocated array</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">qavg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_return_tuple2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">t</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%(name)s</span><span class="s2"> must be a single object or a &quot;</span>
                             <span class="s2">&quot;tuple/list with two objects and not </span><span class="si">%(x)r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">vars</span><span class="p">())</span>

<div class="viewcode-block" id="ContactAnalysis1.output_exists"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis1.output_exists">[docs]</a>    <span class="k">def</span> <span class="nf">output_exists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if default output file already exists.</span>

<span class="sd">        Disable with force=True (will always return False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">force</span> <span class="ow">or</span> <span class="n">force</span><span class="p">)</span></div>

<div class="viewcode-block" id="ContactAnalysis1.run"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis1.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">store</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Analyze trajectory and produce timeseries.</span>

<span class="sd">        Stores results in :attr:`ContactAnalysis1.timeseries` (if store=True)</span>
<span class="sd">        and writes them to a data file. The average q is written to a second</span>
<span class="sd">        data file.</span>

<span class="sd">        *start*</span>
<span class="sd">            The value of the first frame index in the trajectory to be used</span>
<span class="sd">            (default: index 0)</span>
<span class="sd">        *stop*</span>
<span class="sd">            The value of the last frame index in the trajectory to be used</span>
<span class="sd">            (default: None -- use all frames)</span>
<span class="sd">        *step*</span>
<span class="sd">            The number of frames to skip during trajectory iteration (default:</span>
<span class="sd">            use every frame)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s1">&#39;start_frame&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;start_frame argument has been deprecated, use &quot;</span>
                          <span class="s2">&quot;start instead -- removal targeted for version &quot;</span>
                          <span class="s2">&quot;0.15.0&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;start_frame&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;end_frame&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;end_frame argument has been deprecated, use &quot;</span>
                          <span class="s2">&quot;stop instead -- removal targeted for version &quot;</span>
                          <span class="s2">&quot;0.15.0&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;end_frame&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;step_value&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;step_value argument has been deprecated, use &quot;</span>
                          <span class="s2">&quot;step instead -- removal targeted for version &quot;</span>
                          <span class="s2">&quot;0.15.0&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
            <span class="n">step</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;step_value&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_exists</span><span class="p">(</span><span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;File </span><span class="si">%r</span><span class="s2"> already exists, loading it INSTEAD of &quot;</span>
                          <span class="s2">&quot;trajectory </span><span class="si">%r</span><span class="s2">. Use force=True to overwrite &quot;</span>
                          <span class="s2">&quot;the output file. &quot;</span> <span class="o">%</span>
                          <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">filename</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="k">with</span> <span class="n">openany</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">out</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;# q1 analysis</span><span class="se">\n</span><span class="s2"># nref = {0:d}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nref</span><span class="p">)))</span>
            <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;# frame  q1  n1</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">records</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qavg</span> <span class="o">*=</span> <span class="mi">0</span>  <span class="c1"># average contact existence</span>
            <span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selections</span>
            <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">:</span><span class="n">step</span><span class="p">]:</span>
                <span class="n">frame</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">frame</span>
                <span class="c1"># use pre-allocated distance array to save a little bit of time</span>
                <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">distance_array</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(),</span>
                                                        <span class="n">B</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(),</span>
                                                        <span class="n">result</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">)</span>
                <span class="n">n1</span><span class="p">,</span> <span class="n">q1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qN</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_qtmp</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qavg</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span>
                <span class="k">if</span> <span class="n">store</span><span class="p">:</span>
                    <span class="n">records</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">frame</span><span class="p">,</span> <span class="n">q1</span><span class="p">,</span> <span class="n">n1</span><span class="p">))</span>
                <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;{frame:4d}  {q1:8.6f} {n1:5d}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="nb">vars</span><span class="p">()))</span>
        <span class="k">if</span> <span class="n">store</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">records</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">n_frames</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">n_frames</span><span class="p">)[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">:</span><span class="n">step</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">n_frames</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qavg</span> <span class="o">/=</span> <span class="n">n_frames</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;No frames were analyzed. &quot;</span>
                        <span class="s2">&quot;Check values of start, stop, step.&quot;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;start={start} stop={stop} step={step}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="nb">vars</span><span class="p">()))</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outarray</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qavg</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%8.6f</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">output</span></div>

<div class="viewcode-block" id="ContactAnalysis1.qarray"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis1.qarray">[docs]</a>    <span class="k">def</span> <span class="nf">qarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return distance array with True for contacts.</span>

<span class="sd">        *d* is the matrix of distances. The method uses the value of</span>
<span class="sd">        :attr:`ContactAnalysis1.radius` to determine if a ``distance &lt; radius``</span>
<span class="sd">        is considered a contact.</span>

<span class="sd">        If *out* is supplied as a pre-allocated array of the correct</span>
<span class="sd">        shape then it is filled instead of allocating a new one in</span>
<span class="sd">        order to increase performance.</span>

<span class="sd">        This method is typically only used internally.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="ContactAnalysis1.qN"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis1.qN">[docs]</a>    <span class="k">def</span> <span class="nf">qN</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate native contacts relative to reference state.</span>

<span class="sd">        *q* is the matrix of contacts (e.g. :attr:`~ContactAnalysis1.q`).</span>

<span class="sd">        If *out* is supplied as a pre-allocated array of the correct</span>
<span class="sd">        shape then it is filled instead of allocating a new one in</span>
<span class="sd">        order to increase performance.</span>

<span class="sd">        This method is typically only used internally.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qref</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qref</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
        <span class="n">contacts</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">contacts</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">contacts</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nref</span></div>

<div class="viewcode-block" id="ContactAnalysis1.load"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis1.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load the data file.&quot;&quot;&quot;</span>
        <span class="n">records</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="n">openany</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">records</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">records</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qavg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outarray</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IOError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">err</span><span class="o">.</span><span class="n">errno</span> <span class="o">!=</span> <span class="n">errno</span><span class="o">.</span><span class="n">ENOENT</span><span class="p">:</span>
                <span class="k">raise</span></div>

<div class="viewcode-block" id="ContactAnalysis1.plot"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis1.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot q(t).</span>

<span class="sd">        If `filename` is supplied then the figure is also written to file (the</span>
<span class="sd">        suffix determines the file type, e.g. pdf, png, eps, ...). All other</span>
<span class="sd">        keyword arguments are passed on to :func:`pylab.plot`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pylab</span> <span class="kn">import</span> <span class="n">plot</span><span class="p">,</span> <span class="n">xlabel</span><span class="p">,</span> <span class="n">ylabel</span><span class="p">,</span> <span class="n">savefig</span>

        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="s1">&#39;black&#39;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;linewidth&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No timeseries data; &quot;</span>
                             <span class="s2">&quot;do &#39;ContactAnalysis.run(store=True)&#39; first.&quot;</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeseries</span>
        <span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">xlabel</span><span class="p">(</span><span class="s2">r&quot;frame number $t$&quot;</span><span class="p">)</span>
        <span class="n">ylabel</span><span class="p">(</span><span class="s2">r&quot;native contacts $q_1$&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_plot_qavg_pcolor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot :attr:`ContactAnalysis1.qavg`, the matrix of average native</span>
<span class="sd">        contacts.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pylab</span> <span class="kn">import</span> <span class="p">(</span><span class="n">pcolor</span><span class="p">,</span> <span class="n">gca</span><span class="p">,</span> <span class="n">meshgrid</span><span class="p">,</span> <span class="n">xlabel</span><span class="p">,</span> <span class="n">ylabel</span><span class="p">,</span> <span class="n">xlim</span><span class="p">,</span> <span class="n">ylim</span><span class="p">,</span>
                           <span class="n">colorbar</span><span class="p">,</span> <span class="n">savefig</span><span class="p">)</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selections</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">resids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">selections</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">resids</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="n">pcolor</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qavg</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>

        <span class="n">xlim</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">ylim</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>

        <span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;residues&quot;</span><span class="p">)</span>
        <span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;residues&quot;</span><span class="p">)</span>

        <span class="n">colorbar</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

<div class="viewcode-block" id="ContactAnalysis1.plot_qavg"><a class="viewcode-back" href="../../../documentation_pages/analysis/contacts.html#MDAnalysis.analysis.contacts.ContactAnalysis1.plot_qavg">[docs]</a>    <span class="k">def</span> <span class="nf">plot_qavg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot :attr:`ContactAnalysis1.qavg`, the matrix of average native contacts.</span>

<span class="sd">        If *filename* is supplied then the figure is also written to file (the</span>
<span class="sd">        suffix determines the file type, e.g. pdf, png, eps, ...). All other</span>
<span class="sd">        keyword arguments are passed on to :func:`pylab.imshow`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pylab</span> <span class="kn">import</span> <span class="p">(</span><span class="n">imshow</span><span class="p">,</span> <span class="n">xlabel</span><span class="p">,</span> <span class="n">ylabel</span><span class="p">,</span> <span class="n">xlim</span><span class="p">,</span> <span class="n">ylim</span><span class="p">,</span> <span class="n">colorbar</span><span class="p">,</span> <span class="n">cm</span><span class="p">,</span>
                           <span class="n">clf</span><span class="p">,</span> <span class="n">savefig</span><span class="p">)</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selections</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">resids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">selections</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">resids</span>

        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;origin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;lower&#39;</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;aspect&#39;</span><span class="p">,</span> <span class="s1">&#39;equal&#39;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;interpolation&#39;</span><span class="p">,</span> <span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;vmin&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;vmax&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;cmap&#39;</span><span class="p">,</span> <span class="n">cm</span><span class="o">.</span><span class="n">hot</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;extent&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>

        <span class="n">clf</span><span class="p">()</span>
        <span class="n">imshow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qavg</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">xlim</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">ylim</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>

        <span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;residue from {0!r}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection_strings</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;residue from {0!r}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection_strings</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="n">colorbar</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">MDAnalysis 0.16.0-dev0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2005-2015, Naveen Michaud-Agrawal, Elizabeth J. Denning, Christian Beckstein (logo), Joshua L. Adelman, Balasubramanian, Jonathan Barnoud, Alejandro Bernardin, Wouter Boomsma, Bart Bruininks, Sébastien Buchoux, David Caplan, Matthieu Chavent, Robert Delgado, John Detlefs, Xavier Deupi, Jan Domanski, David L. Dotson, Lennard van der Feltz, Philip Fowler, Joseph Goose, Richard J. Gowers, Lukas Grossar, Abhinav Gupta, Benjamin Hall, Eugen Hruska, Kyle J. Huston, Joe Jordan, Max Linke, Jinju Lu, Robert McGibbon, Manuel Nuno Melo, Fiona Naughton, Alex Nesterenko, Hai Nguyen, Mattia F. Palermo, Danny Parton, Joshua L. Phillips, Tyler Reddy, Paul Rigor, Carlos Yanez S., Utkarsh Saxena, Sean L. Seyler, Andy Somogyi, Caio S. Souza, Lukas Stelzl, Gorman Stock, Isaac Virshup, Zhuyi Xue, and Oliver Beckstein.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.5.
    </div>
  </body>
</html>